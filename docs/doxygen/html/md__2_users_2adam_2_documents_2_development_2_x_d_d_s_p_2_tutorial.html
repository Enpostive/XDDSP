<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XDDSP: XDDSP Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XDDSP
   </div>
   <div id="projectbrief">A not-so-simple C++ template library for creating complex DSP networks.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2adam_2_documents_2_development_2_x_d_d_s_p_2_tutorial.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">XDDSP Tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md3"></a></p>
<p>Welcome to this quick tutorial, where we will go over the use of the <a class="el" href="namespace_x_d_d_s_p.html">XDDSP</a> library. First we will introduce some of the basic concepts and the low level classes that encapsulate those concepts. Then we will build a simple component which includes a filter and an LFO. Then we will go over the steps needed to integrate the resulting component into an application.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Design Goals</h2>
<p><a class="el" href="namespace_x_d_d_s_p.html">XDDSP</a> is a header-only template library with a few design goals, which we will explore in this section.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
A common base class for components.</h3>
<p>The base class for the components is called <a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a>. <a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a> is a template base class utilising CRTP (Curiously Recurring Template Pattern). It encapsulates a couple of common features that make up a typical DSP processing loop including the ability to split a process loop into smaller steps and trigger points.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Component inputs and outputs to have human readable names.</h3>
<p>A second base class is used called <a class="el" href="class_x_d_d_s_p_1_1_coupler.html" title="A template class which encapsulates the connection paradigm.">XDDSP::Coupler</a> which also uses CRTP. <a class="el" href="class_x_d_d_s_p_1_1_coupler.html" title="A template class which encapsulates the connection paradigm.">XDDSP::Coupler</a> encapsulates mechanisms for fetching input samples in a consistent way and supports multi-channel connections and bulk transfers. Every input into a component may be specified as a template argument to specify the kind of coupler, and a constructor parameter which initialises the coupler, often with a compile time reference.</p>
<p>Each component class in the library has inputs and outputs exposed as public members which can be addressed by name from other code outside of the component. The <a class="el" href="class_x_d_d_s_p_1_1_coupler.html" title="A template class which encapsulates the connection paradigm.">XDDSP::Coupler</a> class is designed to be exposed this way, encapsulating input and output logic and making it easy to specify the connections between components when designing your DSP network. I have found that most code completion features in modern IDEs can locate and auto-complete input and output names.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Maximising code-encapsulation and reusability.</h3>
<p><a class="el" href="namespace_x_d_d_s_p.html">XDDSP</a> is extremely modular. Each component is made to do just one thing and provide all the necessary connectivity required for its job. This means that, for example, the filter functionality is completely separate from the dynamics processing functionaliy and both are as easily interoperable as with the rest of the functions provided.</p>
<p>Furthermore, common features such as control inputs from the user interface or samples from sample buffers are just as connectable as other components, each being encapsulated inside a class derived from <a class="el" href="class_x_d_d_s_p_1_1_coupler.html" title="A template class which encapsulates the connection paradigm.">XDDSP::Coupler</a>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Portability and independence from other libraries.</h3>
<p>The library is written in C++17, which has become a widely accepted standard with many compilers being available across many platforms. The only prerequisite to use is the C++ standard library. This does mean that <a class="el" href="namespace_x_d_d_s_p.html">XDDSP</a> currently lacks certain important features, such as the ability to load media from disk. However, you may find that implementing a coupler to interface with your favourite codec library is trivial, enabling any component in the library to interface with it.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
As many opportunities for automatic optimisation as possible.</h3>
<p>As <a class="el" href="namespace_x_d_d_s_p.html">XDDSP</a> is predominantly a header-only template library, many C++ compilers can exploit inlining and loop-consolidation tricks to reduce code size and increase performance. My own experience with Clang and Ghidra have shown that complex networks can be reduced into a single inner loop and multi-layer connections between components can be optimised away.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Building A Custom Component</h1>
<p>Custom components in <a class="el" href="namespace_x_d_d_s_p.html">XDDSP</a> consist of template classes which inherit from the <a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a> template. <a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a> exposes an interface to enable and disable the component, along with 6 virtual methods. Any class which inherits from this CRTP class is called a component.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Component Enabling</h4>
<p>You can check if any component is enabled by calling <a class="el" href="class_x_d_d_s_p_1_1_component_base_class.html#Component_isEnabled">XDDSP::Component::isEnabled</a>. You can change the enabled status by calling <a class="el" href="class_x_d_d_s_p_1_1_component_base_class.html#Component_isDisabled">XDDSP::Component::isDisabled</a>. Note that disabling the component will automatically reset it to mute its output buffers.</p>
<p>You put your code to reset the component into <a class="el" href="class_x_d_d_s_p_1_1_component.html#a7fb7ab876decfdd94c1ba3dd9f167545" title="This can be implemented to contain the code used to reset the component to a default known state.">XDDSP::Component::reset</a>. At a minimum, it is expected that <a class="el" href="class_x_d_d_s_p_1_1_component.html#a7fb7ab876decfdd94c1ba3dd9f167545" title="This can be implemented to contain the code used to reset the component to a default known state.">XDDSP::Component::reset</a> will clear the output buffers of the component by filling them with zeroes.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
The Process Loop</h4>
<p><a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a> declares a method called <a class="el" href="class_x_d_d_s_p_1_1_component.html#aac9d097f94ec390ccd24e623c9d7f22c" title="This is the main entry point of the component. This method should be called after all the input sourc...">XDDSP::Component::process</a>. This method should be used by any code external to the component to run the process loop. Care should be taken to ensure that components are processed in the proper order, that is starting with components connected to the inputs and ending with components connected to outputs.</p>
<p>The process loop in a component follows a specific routine. First, <a class="el" href="class_x_d_d_s_p_1_1_component.html#ac71014690b2ff661f495d7d07ddbab93" title="This can be implemented to return a step size to use. It can return the same value each time,...">XDDSP::Component::startProcess</a> is called and the return value is kept as the step size. The step size is allowed to change to be whatever is necessary, as long as it is not bigger than the sampleCount parameter. The intention with step sizes is to allow control signals to be calculated at intervals as opposed to being calculated every sample. A good example is a biquad filter with a frequency input. Even a keen listener is not going to notice when filter coefficents are only updated every 16 samples or so. Being able to process in smaller steps also allows the process loop to "interrupt" the process at a predetermined point in the loop.</p>
<p>After getting the step size, the process loop repeatedly calles <a class="el" href="class_x_d_d_s_p_1_1_component.html#a88928f12d1d0a3624e84e892379132c6" title="Is called repeatedly by Component::process with the start point incremented by step size....">XDDSP::Component::stepProcess</a> with step sized chunks. The process loop may call stepProcess with smaller chunks from time to time. The code inside <a class="el" href="class_x_d_d_s_p_1_1_component.html#a88928f12d1d0a3624e84e892379132c6" title="Is called repeatedly by Component::process with the start point incremented by step size....">XDDSP::Component::stepProcess</a> may call <a class="el" href="class_x_d_d_s_p_1_1_component_base_class.html#Component_setNextTrigger">XDDSP::Component::setNextTrigger</a> to set a trigger point. Because of how symbol resolution works in C++17, this method can only be called by using a "this dereference" like <span class="tt">this-&gt;setNextTrigger(trigger)</span>.</p>
<p>When a trigger point is reached, the process loop calles <a class="el" href="class_x_d_d_s_p_1_1_component.html#a07c07a7f9101fe6e59ac7de4f43f505e" title="Is called when a trigger point is reached.">XDDSP::Component::triggerProcess</a> with the sample location of the trigger point.</p>
<p>After the process loop processes the buffer, it calls <a class="el" href="class_x_d_d_s_p_1_1_component.html#a17c5cf4fb9fe5c30dc6d604e87bff0c4" title="Is called after all the blocks have been processed.">XDDSP::Component::finishProcess</a>.</p>
<p>The <a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a> class implements default methods for all of these methods. All of them are empty methods, except for <a class="el" href="class_x_d_d_s_p_1_1_component.html#ac71014690b2ff661f495d7d07ddbab93" title="This can be implemented to return a step size to use. It can return the same value each time,...">XDDSP::Component::startProcess</a>, the default implementation of which uses a template argument as the return value, unless sampleCount is smaller. This means that implementing a fixed sized step size is just a matter of providing the template argument in the <a class="el" href="class_x_d_d_s_p_1_1_component.html" title="A CRTP component template which encapsulates the implementation of the process loop logic....">XDDSP::Component</a> template parameters.</p>
<p>All of these methods inside the process loop are called from the audio processing thread, meaning that they should be completely non-blocking and optimised for performance. Avoid memory allocations or deallocations, file operations or any other form of blocking IO. Mutex locking for inter-thread communication is sometimes needed to meet this requirement, it is best to keep those critical sections as short as possible.</p>
<p><b>Note: In a future version these virtual methods will not be virtual and thus the object won't be polymorphic. All new software should avoid keeping pointers of <a class="el" href="class_x_d_d_s_p_1_1_component_base_class.html" title="A foundational base class for the CRTP base class to inherit from. Pointers of this type can point to...">XDDSP::ComponentBaseClass</a> and only keep pointers or references to derived classes instead.</b></p>
<hr  />
<h4 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Handy template</h4>
<p>Here is a helpful template which you can copy into your application to use as a component class. </p><pre class="fragment">#include "XDDSP/XDDSP.h"

// Input types are specified as template arguments to the class. Input types go
// first, because they never have defaults.
template &lt;typename SignalIn&gt;
class NewComponent : public Component&lt;NewComponent&lt;SignalIn&gt;&gt; {

  // Private data members here

 public:
  static constexpr int Count = SignalIn::Count;

  // Specify your inputs as public members here
  SignalIn signalIn;

  // Specify your outputs like this
  Output&lt;Count&gt; signalOut;

  // Include a definition for each input in the constructor
  NewComponent(Parameters &amp;p, SignalIn _signalIn) :
  signalIn(_signalIn),
  signalOut(p)
  {}

  // This function is responsible for clearing the output buffers to a default
  // state when the component is disabled.
  void reset() {
    signalOut.reset();
  }

  // startProcess prepares the component for processing one block and returns the 
  // step size. By default, it returns the entire sampleCount as one big step, so
  // this function can be deleted if not required.
  int startProcess(int startPoint, int sampleCount) {
    return std::min(sampleCount, StepSize);
  }

  // stepProcess is called repeatedly with the start point incremented by step size
  void stepProcess(int startPoint, int sampleCount) {
    for (int c = 0; c &lt; Count; ++c) {
      for (int i = startPoint, s = sampleCount; s--; ++i) {
        // DSP work done here
      }
    }
  }

  // triggerProcess is called once if 'samplesToNextTrigger' reaches zero
  // components can use 'setNextTrigger' to set a trigger point. This function can
  // be deleted if not needed.
  void triggerprocess(int triggerPoint) {
  }

  // finishProcess is called after the block has been processed. This function
  // can be deleted if not needed.
  void finishProcess() {
  }
};
</pre><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Adding subcomponents</h3>
<p>Here we have modified the template to include a dynamic biquad and an LFO </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>

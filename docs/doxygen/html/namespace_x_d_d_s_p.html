<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XDDSP: XDDSP Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XDDSP
   </div>
   <div id="projectbrief">A not-so-simple C++ template library for creating complex DSP networks.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespace_x_d_d_s_p.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">XDDSP Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:MixingLaws" id="r_MixingLaws"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_x_d_d_s_p_1_1_mixing_laws.html">MixingLaws</a></td></tr>
<tr class="memdesc:namespace_x_d_d_s_p_1_1_mixing_laws"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixing Laws. <br /></td></tr>
<tr class="memitem:ProcessQuality" id="r_ProcessQuality"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_x_d_d_s_p_1_1_process_quality.html">ProcessQuality</a></td></tr>
<tr class="memdesc:namespace_x_d_d_s_p_1_1_process_quality"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum which can be used in various components to specify the quality level of a particular process. <br /></td></tr>
<tr class="memitem:WindowFunction" id="r_WindowFunction"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_x_d_d_s_p_1_1_window_function.html">WindowFunction</a></td></tr>
<tr class="memdesc:namespace_x_d_d_s_p_1_1_window_function"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace containing classes which can generate various window shapes, useful for many DSP applications. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:LUFSBlockCollector" id="r_LUFSBlockCollector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_l_u_f_s_block_collector.html">LUFSBlockCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures RMS levels and reports the overall loudness as described in the LUFS standard. This component only does the block splitting and RMS measurement parts of the standard. A k-Weighted filter is required to be placed before this component in the signal chain to obtain an actual dBLUFS measurement.  <a href="class_x_d_d_s_p_1_1_l_u_f_s_block_collector.html#details">More...</a><br /></td></tr>
<tr class="memitem:BiquadFilterCoefficients" id="r_BiquadFilterCoefficients"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_biquad_filter_coefficients.html">BiquadFilterCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the state of configuration for a biquad filter.  <a href="class_x_d_d_s_p_1_1_biquad_filter_coefficients.html#details">More...</a><br /></td></tr>
<tr class="memitem:BiquadFilterKernel" id="r_BiquadFilterKernel"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_biquad_filter_kernel.html">BiquadFilterKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple biquad filter implementation. This is not a component. For pre-built components which use this filter, see <a class="el" href="class_x_d_d_s_p_1_1_static_biquad.html" title="A component encapsulating a simple static biquad filter.">StaticBiquad</a> and <a class="el" href="class_x_d_d_s_p_1_1_dynamic_biquad.html" title="A component containing a dynamic biquad filter.">DynamicBiquad</a>.  <a href="class_x_d_d_s_p_1_1_biquad_filter_kernel.html#details">More...</a><br /></td></tr>
<tr class="memitem:BiquadFilterPublicInterface" id="r_BiquadFilterPublicInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_biquad_filter_public_interface.html">BiquadFilterPublicInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient class that can be used to expose the BiquadCoefficients filter response calculators without exposing the configurators.  <a href="class_x_d_d_s_p_1_1_biquad_filter_public_interface.html#details">More...</a><br /></td></tr>
<tr class="memitem:BLEPLookup" id="r_BLEPLookup"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_b_l_e_p_lookup.html">BLEPLookup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class encapsulating the logic to perform lookups in the Band-Limited stEP and Band-Limited rAMP tables.  <a href="class_x_d_d_s_p_1_1_b_l_e_p_lookup.html#details">More...</a><br /></td></tr>
<tr class="memitem:BLEPGenerator" id="r_BLEPGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_b_l_e_p_generator.html">BLEPGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects of this class can be used to trigger and buffer the samples for band limited steps and ramps. These are useful for synthesizing band-limited oscillators and band-limited distortion algorithms.  <a href="class_x_d_d_s_p_1_1_b_l_e_p_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CircularBuffer" id="r_CircularBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_circular_buffer.html">CircularBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing a fixed size circular buffer.  <a href="class_x_d_d_s_p_1_1_circular_buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicCircularBuffer" id="r_DynamicCircularBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_dynamic_circular_buffer.html">DynamicCircularBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing a circular buffer which can be resized.  <a href="class_x_d_d_s_p_1_1_dynamic_circular_buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ModulusCircularBuffer" id="r_ModulusCircularBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_modulus_circular_buffer.html">ModulusCircularBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class implementing a memory efficient circular buffer with a performance penalty.  <a href="class_x_d_d_s_p_1_1_modulus_circular_buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:Coupler" id="r_Coupler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_coupler.html">Coupler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class which encapsulates the connection paradigm.  <a href="class_x_d_d_s_p_1_1_coupler.html#details">More...</a><br /></td></tr>
<tr class="memitem:OutputBuffer" id="r_OutputBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_output_buffer.html">OutputBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a buffer to be used to store output data from a DSP process. Instead of inheriting the coupler code above, a similar interface is presented which returns references to the samples requested, enabling them to be written by DSP code.  <a href="class_x_d_d_s_p_1_1_output_buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:Output" id="r_Output"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_output.html">Output</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output which encapsulates an output buffer inside a coupler so that it can be readily connected to by other components.  <a href="class_x_d_d_s_p_1_1_output.html#details">More...</a><br /></td></tr>
<tr class="memitem:ComponentBaseClass" id="r_ComponentBaseClass"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_component_base_class.html">ComponentBaseClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A foundational base class for the CRTP base class to inherit from. Pointers of this type can point to any component class which enables component containers to work.  <a href="class_x_d_d_s_p_1_1_component_base_class.html#details">More...</a><br /></td></tr>
<tr class="memitem:Component" id="r_Component"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_component.html">Component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP component template which encapsulates the implementation of the process loop logic. A component process loop is split up into 4 parts: reset, start, step and finish. Reset is called as required by the application to reset the component. The start code is called once at the start of each process buffer to process. The step code is called repeatedly to do the actual processing. The finish code is called after the last step call. The process loop can also interrupt itself at a pre-determined time to call a trigger.  <a href="class_x_d_d_s_p_1_1_component.html#details">More...</a><br /></td></tr>
<tr class="memitem:ComponentContainer" id="r_ComponentContainer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_component_container.html">ComponentContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="class_x_d_d_s_p_1_1_component_container.html#details">More...</a><br /></td></tr>
<tr class="memitem:LowQualityDelay" id="r_LowQualityDelay"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_low_quality_delay.html">LowQualityDelay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple delay component with no iterpolation.  <a href="class_x_d_d_s_p_1_1_low_quality_delay.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiTapDelay" id="r_MultiTapDelay"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_multi_tap_delay.html">MultiTapDelay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple delay with multiple taps.  <a href="class_x_d_d_s_p_1_1_multi_tap_delay.html#details">More...</a><br /></td></tr>
<tr class="memitem:MediumQualityDelay" id="r_MediumQualityDelay"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_medium_quality_delay.html">MediumQualityDelay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple delay component with linear interpolation.  <a href="class_x_d_d_s_p_1_1_medium_quality_delay.html#details">More...</a><br /></td></tr>
<tr class="memitem:HighQualityDelay" id="r_HighQualityDelay"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_high_quality_delay.html">HighQualityDelay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple delay component with hermite interpolation.  <a href="class_x_d_d_s_p_1_1_high_quality_delay.html#details">More...</a><br /></td></tr>
<tr class="memitem:Ramp" id="r_Ramp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for generating ramp signals.  <a href="class_x_d_d_s_p_1_1_ramp.html#details">More...</a><br /></td></tr>
<tr class="memitem:RampTo" id="r_RampTo"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_ramp_to.html">RampTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for ramping from a current value to a new value.  <a href="class_x_d_d_s_p_1_1_ramp_to.html#details">More...</a><br /></td></tr>
<tr class="memitem:ADSRGenerator" id="r_ADSRGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_a_d_s_r_generator.html">ADSRGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for generating ADSR envelopes.  <a href="class_x_d_d_s_p_1_1_a_d_s_r_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Trapezoid" id="r_Trapezoid"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_trapezoid.html">Trapezoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This component outputs an Attack-Release envelope controlled by the time input.  <a href="class_x_d_d_s_p_1_1_trapezoid.html#details">More...</a><br /></td></tr>
<tr class="memitem:PiecewiseEnvelopeSampler" id="r_PiecewiseEnvelopeSampler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_piecewise_envelope_sampler.html">PiecewiseEnvelopeSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a piecewise envelope, using an input to control what part of the envelope is sampled.  <a href="class_x_d_d_s_p_1_1_piecewise_envelope_sampler.html#details">More...</a><br /></td></tr>
<tr class="memitem:PiecewiseEnvelope" id="r_PiecewiseEnvelope"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_piecewise_envelope.html">PiecewiseEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a piecewise envelope.  <a href="class_x_d_d_s_p_1_1_piecewise_envelope.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExponentialEnvelopeFollower" id="r_ExponentialEnvelopeFollower"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_exponential_envelope_follower.html">ExponentialEnvelopeFollower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an exponential envelope signal from an input signal.  <a href="class_x_d_d_s_p_1_1_exponential_envelope_follower.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearEnvelopeFollower" id="r_LinearEnvelopeFollower"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_linear_envelope_follower.html">LinearEnvelopeFollower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linear envelope signal from an input signal.  <a href="class_x_d_d_s_p_1_1_linear_envelope_follower.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicsProcessingGainSignal" id="r_DynamicsProcessingGainSignal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_dynamics_processing_gain_signal.html">DynamicsProcessingGainSignal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an envelope signal as input and produces a gain signal for dynamics control.  <a href="class_x_d_d_s_p_1_1_dynamics_processing_gain_signal.html#details">More...</a><br /></td></tr>
<tr class="memitem:AutoCorrelator" id="r_AutoCorrelator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_auto_correlator.html">AutoCorrelator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which pre-allocates a processing buffer to perform autocorrelation.  <a href="class_x_d_d_s_p_1_1_auto_correlator.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicAutoCorrelator" id="r_DynamicAutoCorrelator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_dynamic_auto_correlator.html">DynamicAutoCorrelator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class with a buffer stored in an internal std::vector used for doing antocorrelation,.  <a href="class_x_d_d_s_p_1_1_dynamic_auto_correlator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvolutionFilter" id="r_ConvolutionFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_convolution_filter.html">ConvolutionFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for performing convolution on an input signal.  <a href="class_x_d_d_s_p_1_1_convolution_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:OnePoleAveragingFilter" id="r_OnePoleAveragingFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_one_pole_averaging_filter.html">OnePoleAveragingFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component encapsulating a simple one-pole averaging filter, suitable for use as a simple lowpass filter, control smoother, RMS filter etc.  <a href="class_x_d_d_s_p_1_1_one_pole_averaging_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:StaticBiquad" id="r_StaticBiquad"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_static_biquad.html">StaticBiquad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component encapsulating a simple static biquad filter.  <a href="class_x_d_d_s_p_1_1_static_biquad.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicBiquad" id="r_DynamicBiquad"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_dynamic_biquad.html">DynamicBiquad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component containing a dynamic biquad filter.  <a href="class_x_d_d_s_p_1_1_dynamic_biquad.html#details">More...</a><br /></td></tr>
<tr class="memitem:CrossoverFilter" id="r_CrossoverFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_crossover_filter.html">CrossoverFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component encapsulating a Linkwitz-Riley filter suitable for building phase-aligned crossover filters.  <a href="class_x_d_d_s_p_1_1_crossover_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:FIRHilbertTransform" id="r_FIRHilbertTransform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_f_i_r_hilbert_transform.html">FIRHilbertTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component encapsulating a Hilbert Transform using an FIR.  <a href="class_x_d_d_s_p_1_1_f_i_r_hilbert_transform.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvolutionHilbertFilter" id="r_ConvolutionHilbertFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_convolution_hilbert_filter.html">ConvolutionHilbertFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component encapsulating a Hilbert Transform using a convolution kernel.  <a href="class_x_d_d_s_p_1_1_convolution_hilbert_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:IIRHilbertApproximator" id="r_IIRHilbertApproximator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_i_i_r_hilbert_approximator.html">IIRHilbertApproximator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component encapsulating a hilbert approximator using an IIR filter.  <a href="class_x_d_d_s_p_1_1_i_i_r_hilbert_approximator.html#details">More...</a><br /></td></tr>
<tr class="memitem:MinMax" id="r_MinMax"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_min_max.html">MinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class encapsulating some common min-max functionality.  <a href="class_x_d_d_s_p_1_1_min_max.html#details">More...</a><br /></td></tr>
<tr class="memitem:LogarithmicScale" id="r_LogarithmicScale"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_logarithmic_scale.html">LogarithmicScale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be deprecated in favour of adding this functionality to <a class="el" href="class_x_d_d_s_p_1_1_min_max.html" title="A class encapsulating some common min-max functionality.">MinMax</a>.  <a href="class_x_d_d_s_p_1_1_logarithmic_scale.html#details">More...</a><br /></td></tr>
<tr class="memitem:PowerSize" id="r_PowerSize"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_power_size.html">PowerSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing commonly used functionality in relation to powers of two.  <a href="class_x_d_d_s_p_1_1_power_size.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntegerAndFraction" id="r_IntegerAndFraction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_integer_and_fraction.html">IntegerAndFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class encapsulating the best algorithm for splitting a sample into its integer and fraction components.  <a href="class_x_d_d_s_p_1_1_integer_and_fraction.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearEstimator" id="r_LinearEstimator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_linear_estimator.html">LinearEstimator</a></td></tr>
<tr class="memitem:IntersectionEstimator" id="r_IntersectionEstimator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_intersection_estimator.html">IntersectionEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for estimating the intersection of a cubic waveform and flat line fixed at some value.  <a href="class_x_d_d_s_p_1_1_intersection_estimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:LookupTable" id="r_LookupTable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_lookup_table.html">LookupTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable object which creates a lookup table from a function.  <a href="class_x_d_d_s_p_1_1_lookup_table.html#details">More...</a><br /></td></tr>
<tr class="memitem:Connector" id="r_Connector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_connector.html">Connector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple straight connector to another coupler.  <a href="class_x_d_d_s_p_1_1_connector.html#details">More...</a><br /></td></tr>
<tr class="memitem:PConnector" id="r_PConnector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_p_connector.html">PConnector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connector which can be connected or reconnected to another coupler type at run time.  <a href="class_x_d_d_s_p_1_1_p_connector.html#details">More...</a><br /></td></tr>
<tr class="memitem:ChannelPicker" id="r_ChannelPicker"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_channel_picker.html">ChannelPicker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input for picking one channel from a multi-channel input.  <a href="class_x_d_d_s_p_1_1_channel_picker.html#details">More...</a><br /></td></tr>
<tr class="memitem:BufferCoupler" id="r_BufferCoupler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_buffer_coupler.html">BufferCoupler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler for coupling buffers that are different types (eg. connecting float to double).  <a href="class_x_d_d_s_p_1_1_buffer_coupler.html#details">More...</a><br /></td></tr>
<tr class="memitem:ControlConstant" id="r_ControlConstant"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_control_constant.html">ControlConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler which outputs a constant signal on each channel. A modifier function may be given to modify given control values before they enter the DSP network.  <a href="class_x_d_d_s_p_1_1_control_constant.html#details">More...</a><br /></td></tr>
<tr class="memitem:AudioPropertiesInputMode" id="r_AudioPropertiesInputMode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_d_d_s_p_1_1_audio_properties_input_mode.html">AudioPropertiesInputMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the different modes available to be used in <a class="el" href="class_x_d_d_s_p_1_1_audio_properties_input.html" title="A coupler for producing signals based on a chosen DSP Parameter (such as sample rate or song tempo) T...">AudioPropertiesInput</a>.  <a href="struct_x_d_d_s_p_1_1_audio_properties_input_mode.html#details">More...</a><br /></td></tr>
<tr class="memitem:AudioPropertiesInput" id="r_AudioPropertiesInput"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_audio_properties_input.html">AudioPropertiesInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler for producing signals based on a chosen DSP Parameter (such as sample rate or song tempo) This coupler is similar to <a class="el" href="class_x_d_d_s_p_1_1_control_constant.html" title="A coupler which outputs a constant signal on each channel. A modifier function may be given to modify...">ControlConstant</a>, except that the control signal is taken from the <a class="el" href="class_x_d_d_s_p_1_1_parameters.html" title="An object which encapsulates all of the basic parameters of a DSP network.">Parameters</a> Object and scaled by a multiplier.  <a href="class_x_d_d_s_p_1_1_audio_properties_input.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiIn" id="r_MultiIn"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_multi_in.html">MultiIn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class which encapsulates code for variadic couplers. User applications won't need to instantiate this directly.  <a href="class_x_d_d_s_p_1_1_multi_in.html#details">More...</a><br /></td></tr>
<tr class="memitem:Switch" id="r_Switch"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_switch.html">Switch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler which takes multiple coupler inputs and provides a switch to choose one input for it's output. Each input must have the same number of channels as the output.  <a href="class_x_d_d_s_p_1_1_switch.html#details">More...</a><br /></td></tr>
<tr class="memitem:Sum" id="r_Sum"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_sum.html">Sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler which sums it's coupled inputs. Each input must have the same number of channels as the output.  <a href="class_x_d_d_s_p_1_1_sum.html#details">More...</a><br /></td></tr>
<tr class="memitem:Product" id="r_Product"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_product.html">Product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler which multiplies it's coupled inputs together to produce the output. Each input must have the same number of channels as the output.  <a href="class_x_d_d_s_p_1_1_product.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignalModifier" id="r_SignalModifier"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_signal_modifier.html">SignalModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal modifier coupler which applies a specified function to it's input. This coupler is meant to be a convenient way to apply a simple stateless function, such as a waveshaper, to a signal. The function may be called multiple times for any sample and may be called out of order.  <a href="class_x_d_d_s_p_1_1_signal_modifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:SamplePlaybackHead" id="r_SamplePlaybackHead"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_sample_playback_head.html">SamplePlaybackHead</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler which outputs samples from a sample buffer.  <a href="class_x_d_d_s_p_1_1_sample_playback_head.html#details">More...</a><br /></td></tr>
<tr class="memitem:BufferReader" id="r_BufferReader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_buffer_reader.html">BufferReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler for connecting various length buffers to each channel. Each buffer is expected to be the same type but can have different lengths. Bounds checking is performed.  <a href="class_x_d_d_s_p_1_1_buffer_reader.html#details">More...</a><br /></td></tr>
<tr class="memitem:PluginInput" id="r_PluginInput"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_plugin_input.html">PluginInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coupler which is convenient for connecting as the input for the entire network. Simple bounds checking is provided in debug mode to alert the developer if samples outside of the buffer are being requested.  <a href="class_x_d_d_s_p_1_1_plugin_input.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinkwitzRileyFilterCoefficients" id="r_LinkwitzRileyFilterCoefficients"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_linkwitz_riley_filter_coefficients.html">LinkwitzRileyFilterCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class encapsulating code for generating Linkwitz-Riley filter coefficients.  <a href="class_x_d_d_s_p_1_1_linkwitz_riley_filter_coefficients.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinkwitzRileyFilterKernel" id="r_LinkwitzRileyFilterKernel"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_linkwitz_riley_filter_kernel.html">LinkwitzRileyFilterKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class encapsulating a Linkwitz-Riley filter kernel.  <a href="class_x_d_d_s_p_1_1_linkwitz_riley_filter_kernel.html#details">More...</a><br /></td></tr>
<tr class="memitem:Crossfader" id="r_Crossfader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_crossfader.html">Crossfader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for crossfading between two signals.  <a href="class_x_d_d_s_p_1_1_crossfader.html#details">More...</a><br /></td></tr>
<tr class="memitem:Panner" id="r_Panner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_panner.html">Panner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for panning an input signal between two output signals.  <a href="class_x_d_d_s_p_1_1_panner.html#details">More...</a><br /></td></tr>
<tr class="memitem:StereoPanner" id="r_StereoPanner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_stereo_panner.html">StereoPanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for simplifying the panning of a stereo signal.  <a href="class_x_d_d_s_p_1_1_stereo_panner.html#details">More...</a><br /></td></tr>
<tr class="memitem:MonoToStereoMixBus" id="r_MonoToStereoMixBus"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_mono_to_stereo_mix_bus.html">MonoToStereoMixBus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component with connectable mono inputs.  <a href="class_x_d_d_s_p_1_1_mono_to_stereo_mix_bus.html#details">More...</a><br /></td></tr>
<tr class="memitem:StereoToStereoMixBus" id="r_StereoToStereoMixBus"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_stereo_to_stereo_mix_bus.html">StereoToStereoMixBus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component with connectable stereo inputs.  <a href="class_x_d_d_s_p_1_1_stereo_to_stereo_mix_bus.html#details">More...</a><br /></td></tr>
<tr class="memitem:DebugWatch" id="r_DebugWatch"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_debug_watch.html">DebugWatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input only component which can come in handy when debugging your DSP Network.  <a href="class_x_d_d_s_p_1_1_debug_watch.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignalProbe" id="r_SignalProbe"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_signal_probe.html">SignalProbe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A probe suitable for measureing minimum, maximum and instantaneous values in a signal and reading them from non-DSP code.  <a href="class_x_d_d_s_p_1_1_signal_probe.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignalAverage" id="r_SignalAverage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_signal_average.html">SignalAverage</a></td></tr>
<tr class="memitem:InterfaceBuffer" id="r_InterfaceBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_interface_buffer.html">InterfaceBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which buffers samples from its input and makes them available in a thread safe manner.  <a href="class_x_d_d_s_p_1_1_interface_buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:RandomNumberBuffer" id="r_RandomNumberBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_random_number_buffer.html">RandomNumberBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for accessing a global lookup table made of random numbers.  <a href="class_x_d_d_s_p_1_1_random_number_buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:NoiseGenerator" id="r_NoiseGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_noise_generator.html">NoiseGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which outputs white noise.  <a href="class_x_d_d_s_p_1_1_noise_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PinkNoiseGenerator" id="r_PinkNoiseGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_pink_noise_generator.html">PinkNoiseGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which outputs pink noise.  <a href="class_x_d_d_s_p_1_1_pink_noise_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnalogNoiseSimulator" id="r_AnalogNoiseSimulator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_analog_noise_simulator.html">AnalogNoiseSimulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component for adding convincing analog noise to a signal.  <a href="class_x_d_d_s_p_1_1_analog_noise_simulator.html#details">More...</a><br /></td></tr>
<tr class="memitem:FuncOscillator" id="r_FuncOscillator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_func_oscillator.html">FuncOscillator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic multi-channel oscillator which uses a callable object to generate a waveform.  <a href="class_x_d_d_s_p_1_1_func_oscillator.html#details">More...</a><br /></td></tr>
<tr class="memitem:BandLimitedSawOscillator" id="r_BandLimitedSawOscillator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_band_limited_saw_oscillator.html">BandLimitedSawOscillator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-channel band-limited sawtooth oscillator.  <a href="class_x_d_d_s_p_1_1_band_limited_saw_oscillator.html#details">More...</a><br /></td></tr>
<tr class="memitem:BandLimitedSquareOscillator" id="r_BandLimitedSquareOscillator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_band_limited_square_oscillator.html">BandLimitedSquareOscillator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-channel band-limited square wave oscillator with PWM input.  <a href="class_x_d_d_s_p_1_1_band_limited_square_oscillator.html#details">More...</a><br /></td></tr>
<tr class="memitem:BandLimitedTriangleOscillator" id="r_BandLimitedTriangleOscillator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_band_limited_triangle_oscillator.html">BandLimitedTriangleOscillator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-channel band-limited triangle wave oscillator.  <a href="class_x_d_d_s_p_1_1_band_limited_triangle_oscillator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Parameters" id="r_Parameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_parameters.html">Parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object which encapsulates all of the basic parameters of a DSP network.  <a href="class_x_d_d_s_p_1_1_parameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:PiecewiseEnvelopeListener" id="r_PiecewiseEnvelopeListener"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_piecewise_envelope_listener.html">PiecewiseEnvelopeListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a listener which is notified of changes to a piecewise envelope.  <a href="class_x_d_d_s_p_1_1_piecewise_envelope_listener.html#details">More...</a><br /></td></tr>
<tr class="memitem:PiecewiseEnvelopeData" id="r_PiecewiseEnvelopeData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_piecewise_envelope_data.html">PiecewiseEnvelopeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing a data structure to describe a piecewise envelope and code to synthesise the envelope.  <a href="class_x_d_d_s_p_1_1_piecewise_envelope_data.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolySynthParameters" id="r_PolySynthParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_poly_synth_parameters.html">PolySynthParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of <a class="el" href="class_x_d_d_s_p_1_1_parameters.html" title="An object which encapsulates all of the basic parameters of a DSP network.">Parameters</a> that contains extra parameters suitable for a MIDI polyphonic synthesiser.  <a href="class_x_d_d_s_p_1_1_poly_synth_parameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:SummingArray" id="r_SummingArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_summing_array.html">SummingArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special component which creates an array of internal component and sums an output to one output.  <a href="class_x_d_d_s_p_1_1_summing_array.html#details">More...</a><br /></td></tr>
<tr class="memitem:MIDIScheduler" id="r_MIDIScheduler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_m_i_d_i_scheduler.html">MIDIScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which takes MIDI events and outputs a signal for each.  <a href="class_x_d_d_s_p_1_1_m_i_d_i_scheduler.html#details">More...</a><br /></td></tr>
<tr class="memitem:MIDIPoly" id="r_MIDIPoly"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_m_i_d_i_poly.html">MIDIPoly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special component which connects to a collection of voices to make a polyphonic component.  <a href="class_x_d_d_s_p_1_1_m_i_d_i_poly.html#details">More...</a><br /></td></tr>
<tr class="memitem:MixDown" id="r_MixDown"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_mix_down.html">MixDown</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which couples an array of inputs and sums them into a single output.  <a href="class_x_d_d_s_p_1_1_mix_down.html#details">More...</a><br /></td></tr>
<tr class="memitem:SimpleGain" id="r_SimpleGain"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_simple_gain.html">SimpleGain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which applies a gain signal to an input.  <a href="class_x_d_d_s_p_1_1_simple_gain.html#details">More...</a><br /></td></tr>
<tr class="memitem:Rectifier" id="r_Rectifier"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_rectifier.html">Rectifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which rectifies a signal.  <a href="class_x_d_d_s_p_1_1_rectifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignalDelta" id="r_SignalDelta"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_signal_delta.html">SignalDelta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which takes an input signal and outputs a delta signal.  <a href="class_x_d_d_s_p_1_1_signal_delta.html#details">More...</a><br /></td></tr>
<tr class="memitem:Clipper" id="r_Clipper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_clipper.html">Clipper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which constrains a signal between two other signals.  <a href="class_x_d_d_s_p_1_1_clipper.html#details">More...</a><br /></td></tr>
<tr class="memitem:Maximum" id="r_Maximum"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_maximum.html">Maximum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which takes multiple signals and outputs the signal which has the highest level.  <a href="class_x_d_d_s_p_1_1_maximum.html#details">More...</a><br /></td></tr>
<tr class="memitem:TimeSignal" id="r_TimeSignal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_time_signal.html">TimeSignal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which outputs three time signals.  <a href="class_x_d_d_s_p_1_1_time_signal.html#details">More...</a><br /></td></tr>
<tr class="memitem:Counter" id="r_Counter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_counter.html">Counter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter object.  <a href="class_x_d_d_s_p_1_1_counter.html#details">More...</a><br /></td></tr>
<tr class="memitem:LoopCounter" id="r_LoopCounter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_loop_counter.html">LoopCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter object.  <a href="class_x_d_d_s_p_1_1_loop_counter.html#details">More...</a><br /></td></tr>
<tr class="memitem:TopBottomSwitch" id="r_TopBottomSwitch"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_top_bottom_switch.html">TopBottomSwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects between two different signals depending on the sign of a third.  <a href="class_x_d_d_s_p_1_1_top_bottom_switch.html#details">More...</a><br /></td></tr>
<tr class="memitem:ControlModulatorModes" id="r_ControlModulatorModes"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_d_d_s_p_1_1_control_modulator_modes.html">ControlModulatorModes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the enum which select the mode of <a class="el" href="class_x_d_d_s_p_1_1_control_modulator.html" title="A component which translates signals from an LFO or an envelope to a control range.">ControlModulator</a>.  <a href="struct_x_d_d_s_p_1_1_control_modulator_modes.html#details">More...</a><br /></td></tr>
<tr class="memitem:ControlModulator" id="r_ControlModulator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_control_modulator.html">ControlModulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which translates signals from an LFO or an envelope to a control range.  <a href="class_x_d_d_s_p_1_1_control_modulator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Waveshaper" id="r_Waveshaper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_waveshaper.html">Waveshaper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component which applies a waveshaping function to an input.  <a href="class_x_d_d_s_p_1_1_waveshaper.html#details">More...</a><br /></td></tr>
<tr class="memitem:WaveshapeLookupTable" id="r_WaveshapeLookupTable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_x_d_d_s_p_1_1_waveshape_lookup_table.html">WaveshapeLookupTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable function object which transforms the input signal using a lookup table.  <a href="class_x_d_d_s_p_1_1_waveshape_lookup_table.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad1624a1ae09f6160d57a313c29e00c75" id="r_ad1624a1ae09f6160d57a313c29e00c75"><td class="memItemLeft" align="right" valign="top"><a id="ad1624a1ae09f6160d57a313c29e00c75" name="ad1624a1ae09f6160d57a313c29e00c75"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>SampleType</b></td></tr>
<tr class="memitem:a5bbd5553322b93e5506c7cadb0373bbe" id="r_a5bbd5553322b93e5506c7cadb0373bbe"><td class="memItemLeft" align="right" valign="top"><a id="a5bbd5553322b93e5506c7cadb0373bbe" name="a5bbd5553322b93e5506c7cadb0373bbe"></a>
typedef std::function&lt; SampleType(SampleType)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WaveformFunction</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab967fac6eda3e8d7d43c4f9db061e1ef" id="r_ab967fac6eda3e8d7d43c4f9db061e1ef"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab967fac6eda3e8d7d43c4f9db061e1ef template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab967fac6eda3e8d7d43c4f9db061e1ef">fftDynamicSize</a> (T *data, unsigned long n, bool normalise=true)</td></tr>
<tr class="memdesc:ab967fac6eda3e8d7d43c4f9db061e1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an FFT inside an arbitrary buffer.  <br /></td></tr>
<tr class="memitem:a0759011c633e1819484046214fbc3720" id="r_a0759011c633e1819484046214fbc3720"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0759011c633e1819484046214fbc3720 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0759011c633e1819484046214fbc3720">ifftDynamicSize</a> (T *data, unsigned long n)</td></tr>
<tr class="memdesc:a0759011c633e1819484046214fbc3720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an FFT back into the time domain.  <br /></td></tr>
<tr class="memitem:a6cf696b87a8fbae2251aa09ca0689104" id="r_a6cf696b87a8fbae2251aa09ca0689104"><td class="memTemplParams" colspan="2">template&lt;typename T, unsigned long n&gt; </td></tr>
<tr class="memitem:a6cf696b87a8fbae2251aa09ca0689104 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf696b87a8fbae2251aa09ca0689104">fftStaticSize</a> (std::array&lt; T, n &gt; &amp;data, bool normalise=true)</td></tr>
<tr class="memdesc:a6cf696b87a8fbae2251aa09ca0689104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an FFT on data in a std::array.  <br /></td></tr>
<tr class="memitem:ad76647b135a18390ad9d051a97397e0f" id="r_ad76647b135a18390ad9d051a97397e0f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad76647b135a18390ad9d051a97397e0f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad76647b135a18390ad9d051a97397e0f">fftDynamicSize</a> (std::vector&lt; T &gt; &amp;data, bool normalise=true)</td></tr>
<tr class="memdesc:ad76647b135a18390ad9d051a97397e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an FFT on data in a std::vector.  <br /></td></tr>
<tr class="memitem:aaf6a3faaf5f63e44e0684a1f6f632427" id="r_aaf6a3faaf5f63e44e0684a1f6f632427"><td class="memTemplParams" colspan="2">template&lt;typename T, unsigned long n&gt; </td></tr>
<tr class="memitem:aaf6a3faaf5f63e44e0684a1f6f632427 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf6a3faaf5f63e44e0684a1f6f632427">ifftStaticSize</a> (std::array&lt; T, n &gt; &amp;data)</td></tr>
<tr class="memdesc:aaf6a3faaf5f63e44e0684a1f6f632427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an inverse FFT on samples in a std::array.  <br /></td></tr>
<tr class="memitem:ae742e09f1ba85045aa0673a52a33cee3" id="r_ae742e09f1ba85045aa0673a52a33cee3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae742e09f1ba85045aa0673a52a33cee3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae742e09f1ba85045aa0673a52a33cee3">ifftDynamicSize</a> (std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:ae742e09f1ba85045aa0673a52a33cee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input samples are transformed in place from the frequency domain to the time domain. The input consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half.  <br /></td></tr>
<tr class="memitem:a2f46009fa77b26f0939f3f02d9db9d8d" id="r_a2f46009fa77b26f0939f3f02d9db9d8d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2f46009fa77b26f0939f3f02d9db9d8d template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; T, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f46009fa77b26f0939f3f02d9db9d8d">getComplexSample</a> (T *data, unsigned long index, unsigned long n)</td></tr>
<tr class="memdesc:a2f46009fa77b26f0939f3f02d9db9d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a complex sample from an FFT result.  <br /></td></tr>
<tr class="memitem:a301ddf32610b2c3725c8f42064350a23" id="r_a301ddf32610b2c3725c8f42064350a23"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a301ddf32610b2c3725c8f42064350a23 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301ddf32610b2c3725c8f42064350a23">multiplyFFTs</a> (T *output, T *in1, T *in2, unsigned long n)</td></tr>
<tr class="memdesc:a301ddf32610b2c3725c8f42064350a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a complex multiplication of two FFTs.  <br /></td></tr>
<tr class="memitem:a13223a5b4d04516032a1c4f98aeedfeb" id="r_a13223a5b4d04516032a1c4f98aeedfeb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a13223a5b4d04516032a1c4f98aeedfeb template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13223a5b4d04516032a1c4f98aeedfeb">multiplyAndAddFFTs</a> (T *output, T *in1, T *in2, unsigned long n)</td></tr>
<tr class="memdesc:a13223a5b4d04516032a1c4f98aeedfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two FFTs together and add the result to another FFT result.  <br /></td></tr>
<tr class="memitem:a928440e390d14ed481c7743382c72c7f" id="r_a928440e390d14ed481c7743382c72c7f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a928440e390d14ed481c7743382c72c7f template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928440e390d14ed481c7743382c72c7f">magnitudeAt</a> (T *data, unsigned long index, unsigned long n)</td></tr>
<tr class="memdesc:a928440e390d14ed481c7743382c72c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the magnitude of one complex number in the FFT result.  <br /></td></tr>
<tr class="memitem:af74876c324ecde0826f5c56df11061af" id="r_af74876c324ecde0826f5c56df11061af"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:af74876c324ecde0826f5c56df11061af template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74876c324ecde0826f5c56df11061af">calculateMagnitudes</a> (T *data, unsigned long n)</td></tr>
<tr class="memdesc:af74876c324ecde0826f5c56df11061af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate every magnitude in an FFT. The FFT is overwritten with magnitudes in the first half of the buffer, and zeros in the second half.  <br /></td></tr>
<tr class="memitem:ad2f74eac40d5e02fc4b1d798f850f7a7" id="r_ad2f74eac40d5e02fc4b1d798f850f7a7"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad2f74eac40d5e02fc4b1d798f850f7a7 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2f74eac40d5e02fc4b1d798f850f7a7">autoCorrelateDynamicSizeHalved</a> (T *data, unsigned long n)</td></tr>
<tr class="memdesc:ad2f74eac40d5e02fc4b1d798f850f7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do autocorrelation on the input data. The input data is destroyed.  <br /></td></tr>
<tr class="memitem:a5b9681700449b15a061db6007d0815c2" id="r_a5b9681700449b15a061db6007d0815c2"><td class="memTemplParams" colspan="2">template&lt;typename T, unsigned long n&gt; </td></tr>
<tr class="memitem:a5b9681700449b15a061db6007d0815c2 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9681700449b15a061db6007d0815c2">autoCorrelateStaticSizeHalved</a> (std::array&lt; T, n &gt; &amp;data)</td></tr>
<tr class="memdesc:a5b9681700449b15a061db6007d0815c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do autocorrelation on the input data in a std::array. The input data is destroyed.  <br /></td></tr>
<tr class="memitem:a83519386b0c744ec1c58e02a9f22e26a" id="r_a83519386b0c744ec1c58e02a9f22e26a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a83519386b0c744ec1c58e02a9f22e26a template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83519386b0c744ec1c58e02a9f22e26a">autoCorrelateDynamicSizeHalved</a> (std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:a83519386b0c744ec1c58e02a9f22e26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do autocorrelation on the input data in a std::vector. The input data is destroyed.  <br /></td></tr>
<tr class="memitem:a0ab262c14ede5a4325ccfe2ee1c2884a" id="r_a0ab262c14ede5a4325ccfe2ee1c2884a"><td class="memTemplParams" colspan="2"><a id="a0ab262c14ede5a4325ccfe2ee1c2884a" name="a0ab262c14ede5a4325ccfe2ee1c2884a"></a>
template&lt;typename Impulse, typename T = SampleType&gt; </td></tr>
<tr class="memitem:a0ab262c14ede5a4325ccfe2ee1c2884a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>generateImpulseResponse</b> (Impulse impulse, T *data, int length)</td></tr>
<tr class="memitem:a0508502f60edb5fb0a9bb984bc1547b4" id="r_a0508502f60edb5fb0a9bb984bc1547b4"><td class="memTemplParams" colspan="2"><a id="a0508502f60edb5fb0a9bb984bc1547b4" name="a0508502f60edb5fb0a9bb984bc1547b4"></a>
template&lt;typename Impulse, typename T, unsigned long length&gt; </td></tr>
<tr class="memitem:a0508502f60edb5fb0a9bb984bc1547b4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>generateImpulseResponse</b> (Impulse impulse, std::array&lt; T, length &gt; &amp;data)</td></tr>
<tr class="memitem:ac4565ab8237a7dc971ab5f3341735ae0" id="r_ac4565ab8237a7dc971ab5f3341735ae0"><td class="memTemplParams" colspan="2"><a id="ac4565ab8237a7dc971ab5f3341735ae0" name="ac4565ab8237a7dc971ab5f3341735ae0"></a>
template&lt;typename Impulse, typename T&gt; </td></tr>
<tr class="memitem:ac4565ab8237a7dc971ab5f3341735ae0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>generateImpulseResponse</b> (Impulse impulse, std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memitem:af19e51736d4198284ccb3ec9a4c2b7c1" id="r_af19e51736d4198284ccb3ec9a4c2b7c1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:af19e51736d4198284ccb3ec9a4c2b7c1 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19e51736d4198284ccb3ec9a4c2b7c1">boundary</a> (T x, T low, T high)</td></tr>
<tr class="memdesc:af19e51736d4198284ccb3ec9a4c2b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a number between a lower and a higher boundary.  <br /></td></tr>
<tr class="memitem:a6a36f34613d8efa455c8291cbecd6372" id="r_a6a36f34613d8efa455c8291cbecd6372"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6a36f34613d8efa455c8291cbecd6372 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a36f34613d8efa455c8291cbecd6372">clip</a> (T x, T limit)</td></tr>
<tr class="memdesc:a6a36f34613d8efa455c8291cbecd6372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain a number to a maximum magnitude.  <br /></td></tr>
<tr class="memitem:a28800de13ab70bf12e6fb48746ca32b7" id="r_a28800de13ab70bf12e6fb48746ca32b7"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28800de13ab70bf12e6fb48746ca32b7">fastMax</a> (SampleType a, SampleType b)</td></tr>
<tr class="memdesc:a28800de13ab70bf12e6fb48746ca32b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder method to encapsulate the fastest possible method of computing the maximum between two samples.  <br /></td></tr>
<tr class="memitem:abf6c7288a1dc9d8d759f9569085b9bad" id="r_abf6c7288a1dc9d8d759f9569085b9bad"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf6c7288a1dc9d8d759f9569085b9bad">fastMin</a> (SampleType a, SampleType b)</td></tr>
<tr class="memdesc:abf6c7288a1dc9d8d759f9569085b9bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder method to encapsulate the fastest possible method of computing the smaller of two samples.  <br /></td></tr>
<tr class="memitem:a13c3f9f1228f7211d9b338ce2a832858" id="r_a13c3f9f1228f7211d9b338ce2a832858"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c3f9f1228f7211d9b338ce2a832858">fastBoundary</a> (SampleType x, SampleType min, SampleType max)</td></tr>
<tr class="memdesc:a13c3f9f1228f7211d9b338ce2a832858"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder method to encapsulate the fastest possible method of clamping a sample between between two samples.  <br /></td></tr>
<tr class="memitem:a2bfc921fa0143efe506fcb074371add7" id="r_a2bfc921fa0143efe506fcb074371add7"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bfc921fa0143efe506fcb074371add7">fastClip</a> (SampleType x, SampleType limit)</td></tr>
<tr class="memdesc:a2bfc921fa0143efe506fcb074371add7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder method to encapsulate the fastest possible method of clipping a sample to a maximum magnitude.  <br /></td></tr>
<tr class="memitem:a7771496745c2cb5da2ab885b12cfedc0" id="r_a7771496745c2cb5da2ab885b12cfedc0"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7771496745c2cb5da2ab885b12cfedc0">linear2dB</a> (SampleType l)</td></tr>
<tr class="memdesc:a7771496745c2cb5da2ab885b12cfedc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a linear sample (measurement, gain etc.) to a dB sample.  <br /></td></tr>
<tr class="memitem:a4fc7aa4ea6fd39f42da645a95cd445bd" id="r_a4fc7aa4ea6fd39f42da645a95cd445bd"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc7aa4ea6fd39f42da645a95cd445bd">dB2Linear</a> (SampleType dB)</td></tr>
<tr class="memdesc:a4fc7aa4ea6fd39f42da645a95cd445bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a dB sample (measurement, gain etc.) to a linear sample.  <br /></td></tr>
<tr class="memitem:a72d684c645e0b21ea21c660634b25490" id="r_a72d684c645e0b21ea21c660634b25490"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72d684c645e0b21ea21c660634b25490">LERP</a> (SampleType fracPos, SampleType x0, SampleType x1)</td></tr>
<tr class="memdesc:a72d684c645e0b21ea21c660634b25490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a linear interpolation between two samples.  <br /></td></tr>
<tr class="memitem:a37eb3c5613382777208b6577d7a0701a" id="r_a37eb3c5613382777208b6577d7a0701a"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37eb3c5613382777208b6577d7a0701a">hermite</a> (SampleType fracPos, SampleType xm1, SampleType x0, SampleType x1, SampleType x2)</td></tr>
<tr class="memdesc:a37eb3c5613382777208b6577d7a0701a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermite interpolation.  <br /></td></tr>
<tr class="memitem:a6afd36f7351fd88289d49f89dead1e95" id="r_a6afd36f7351fd88289d49f89dead1e95"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6afd36f7351fd88289d49f89dead1e95">exponentialCurve</a> (SampleType min, SampleType max, SampleType input, SampleType exp)</td></tr>
<tr class="memdesc:a6afd36f7351fd88289d49f89dead1e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a linear control to an exponential curve between a minimum and a maximum.  <br /></td></tr>
<tr class="memitem:ae8f4d7f6de8b2e0fcade84032fbe4ac6" id="r_ae8f4d7f6de8b2e0fcade84032fbe4ac6"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8f4d7f6de8b2e0fcade84032fbe4ac6">exponentialDeltaCurve</a> (SampleType min, SampleType delta, SampleType input, SampleType exp)</td></tr>
<tr class="memdesc:ae8f4d7f6de8b2e0fcade84032fbe4ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a linear control to an exponential curve described by a minimum and a delta value.  <br /></td></tr>
<tr class="memitem:a3536440b8c33e7e3a21e583f755cdcf3" id="r_a3536440b8c33e7e3a21e583f755cdcf3"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3536440b8c33e7e3a21e583f755cdcf3">inverseExponentialDeltaCurve</a> (SampleType min, SampleType delta, SampleType output, SampleType exp)</td></tr>
<tr class="memdesc:a3536440b8c33e7e3a21e583f755cdcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an exponential curve value back to a linear value.  <br /></td></tr>
<tr class="memitem:ae86a3e6c2cb74bff4444cbca9fdbebc8" id="r_ae86a3e6c2cb74bff4444cbca9fdbebc8"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae86a3e6c2cb74bff4444cbca9fdbebc8">expCoef</a> (SampleType samples)</td></tr>
<tr class="memdesc:ae86a3e6c2cb74bff4444cbca9fdbebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an exponential decay coefficient that drops to 1% within a certain number of samples.  <br /></td></tr>
<tr class="memitem:a595cef024b93e3dcff48eaec09744c78" id="r_a595cef024b93e3dcff48eaec09744c78"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a595cef024b93e3dcff48eaec09744c78 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a595cef024b93e3dcff48eaec09744c78">signum</a> (T x)</td></tr>
<tr class="memdesc:a595cef024b93e3dcff48eaec09744c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method to calulcate the sign of any number type.  <br /></td></tr>
<tr class="memitem:aa44bb322023297302d2a7d1be3e79751" id="r_aa44bb322023297302d2a7d1be3e79751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44bb322023297302d2a7d1be3e79751">expTrack</a> (SampleType &amp;value, SampleType target, SampleType factor)</td></tr>
<tr class="memdesc:aa44bb322023297302d2a7d1be3e79751"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quick method which takes a variable passed by reference and decays it towards the target at the given factor.  <br /></td></tr>
<tr class="memitem:a495ea5d832c379767c0a40ed981e8b6c" id="r_a495ea5d832c379767c0a40ed981e8b6c"><td class="memItemLeft" align="right" valign="top">SampleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495ea5d832c379767c0a40ed981e8b6c">semitoneRatio</a> (SampleType st)</td></tr>
<tr class="memdesc:a495ea5d832c379767c0a40ed981e8b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the ratio between two equal tempered notes.  <br /></td></tr>
<tr class="memitem:a9ad6f19001c4bae51b38ed50fb9deecd" id="r_a9ad6f19001c4bae51b38ed50fb9deecd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad6f19001c4bae51b38ed50fb9deecd">lowestBitSet</a> (uint32_t word)</td></tr>
<tr class="memdesc:a9ad6f19001c4bae51b38ed50fb9deecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the lowest bit set in a 32-bit unsigned integer.  <br /></td></tr>
<tr class="memitem:a1fafe6f59af92621f69002db3a56855b" id="r_a1fafe6f59af92621f69002db3a56855b"><td class="memItemLeft" align="right" valign="top"><a id="a1fafe6f59af92621f69002db3a56855b" name="a1fafe6f59af92621f69002db3a56855b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>recursiveBinarySearch</b> (int start, int end, std::function&lt; bool(int)&gt; f)</td></tr>
<tr class="memitem:a92ad0de691d167b14c2bd389b06bb8c2" id="r_a92ad0de691d167b14c2bd389b06bb8c2"><td class="memTemplParams" colspan="2"><a id="a92ad0de691d167b14c2bd389b06bb8c2" name="a92ad0de691d167b14c2bd389b06bb8c2"></a>
template&lt;std::size_t ... Is, typename T&gt; </td></tr>
<tr class="memitem:a92ad0de691d167b14c2bd389b06bb8c2 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, sizeof...(Is)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_array_impl</b> (const T &amp;def, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memitem:a442b7ec6b7d6e2d420e735baee0e7ad2" id="r_a442b7ec6b7d6e2d420e735baee0e7ad2"><td class="memTemplParams" colspan="2"><a id="a442b7ec6b7d6e2d420e735baee0e7ad2" name="a442b7ec6b7d6e2d420e735baee0e7ad2"></a>
template&lt;std::size_t N, typename T&gt; </td></tr>
<tr class="memitem:a442b7ec6b7d6e2d420e735baee0e7ad2 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_array</b> (const T &amp;def)</td></tr>
<tr class="memitem:a89da4f40a34d0057fd208afc24217f17" id="r_a89da4f40a34d0057fd208afc24217f17"><td class="memTemplParams" colspan="2"><a id="a89da4f40a34d0057fd208afc24217f17" name="a89da4f40a34d0057fd208afc24217f17"></a>
template&lt;typename T, std::size_t ... Is&gt; </td></tr>
<tr class="memitem:a89da4f40a34d0057fd208afc24217f17 template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, sizeof...(Is)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_component_array_impl</b> (<a class="el" href="class_x_d_d_s_p_1_1_parameters.html">Parameters</a> &amp;p, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memitem:aaa5bc6c0eb8b37e3765ffa4d7790bddd" id="r_aaa5bc6c0eb8b37e3765ffa4d7790bddd"><td class="memTemplParams" colspan="2"><a id="aaa5bc6c0eb8b37e3765ffa4d7790bddd" name="aaa5bc6c0eb8b37e3765ffa4d7790bddd"></a>
template&lt;std::size_t N, typename T&gt; </td></tr>
<tr class="memitem:aaa5bc6c0eb8b37e3765ffa4d7790bddd template"><td class="memItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>makeComponentArray</b> (<a class="el" href="class_x_d_d_s_p_1_1_parameters.html">Parameters</a> &amp;p)</td></tr>
<tr class="memitem:a70350ab317997473442253182bda40ef" id="r_a70350ab317997473442253182bda40ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70350ab317997473442253182bda40ef">dsp_assert</a> (bool condition)</td></tr>
<tr class="memdesc:a70350ab317997473442253182bda40ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static global method to enable assertion checking in debug builds.  <br /></td></tr>
<tr class="memitem:a32fa51674b6f683796cc7417542e97dc" id="r_a32fa51674b6f683796cc7417542e97dc"><td class="memTemplParams" colspan="2">template&lt;typename WindowType, typename T = SampleType&gt; </td></tr>
<tr class="memitem:a32fa51674b6f683796cc7417542e97dc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32fa51674b6f683796cc7417542e97dc">applyWindowFunction</a> (WindowType window, T *data, unsigned long length)</td></tr>
<tr class="memdesc:a32fa51674b6f683796cc7417542e97dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a window function to samples inside an array.  <br /></td></tr>
<tr class="memitem:ac4a07e58ac653667251d968aa5f44ae0" id="r_ac4a07e58ac653667251d968aa5f44ae0"><td class="memTemplParams" colspan="2">template&lt;typename WindowType, typename T, unsigned long length&gt; </td></tr>
<tr class="memitem:ac4a07e58ac653667251d968aa5f44ae0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4a07e58ac653667251d968aa5f44ae0">applyWindowFunction</a> (WindowType window, std::array&lt; T, length &gt; &amp;data)</td></tr>
<tr class="memdesc:ac4a07e58ac653667251d968aa5f44ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a window function to samples inside a std::array.  <br /></td></tr>
<tr class="memitem:aac465980f7ca3efee65c9463f5a5c417" id="r_aac465980f7ca3efee65c9463f5a5c417"><td class="memTemplParams" colspan="2">template&lt;typename WindowType, typename T&gt; </td></tr>
<tr class="memitem:aac465980f7ca3efee65c9463f5a5c417 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac465980f7ca3efee65c9463f5a5c417">applyWindowFunction</a> (WindowType window, std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:aac465980f7ca3efee65c9463f5a5c417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a window function to samples inside a std::vector.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7b599493c3e3781098eefcb500df6008" id="r_a7b599493c3e3781098eefcb500df6008"><td class="memItemLeft" align="right" valign="top"><a id="a7b599493c3e3781098eefcb500df6008" name="a7b599493c3e3781098eefcb500df6008"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerMaximum</b> = INT_MAX</td></tr>
<tr class="memitem:a8edfe00ca46554b95d3253cdb91861fc" id="r_a8edfe00ca46554b95d3253cdb91861fc"><td class="memItemLeft" align="right" valign="top"><a id="a8edfe00ca46554b95d3253cdb91861fc" name="a8edfe00ca46554b95d3253cdb91861fc"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>ABeforeMiddleC</b> = 69</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ac4a07e58ac653667251d968aa5f44ae0" name="ac4a07e58ac653667251d968aa5f44ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a07e58ac653667251d968aa5f44ae0">&#9670;&#160;</a></span>applyWindowFunction() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WindowType, typename T, unsigned long length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::applyWindowFunction </td>
          <td>(</td>
          <td class="paramtype">WindowType</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, length &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a window function to samples inside a std::array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WindowType</td><td>The class of window function, which is implied from the window parameter. </td></tr>
    <tr><td class="paramname">T</td><td>The sample type, which is implied from the data parameter. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, implied from the data parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>An instance of one of the above window objects. </td></tr>
    <tr><td class="paramname">data</td><td>A reference to the std::array containing the sample data to apply the window to. The array is overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac465980f7ca3efee65c9463f5a5c417" name="aac465980f7ca3efee65c9463f5a5c417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac465980f7ca3efee65c9463f5a5c417">&#9670;&#160;</a></span>applyWindowFunction() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WindowType, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::applyWindowFunction </td>
          <td>(</td>
          <td class="paramtype">WindowType</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a window function to samples inside a std::vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WindowType</td><td>The class of window function, which is implied from the window parameter. </td></tr>
    <tr><td class="paramname">T</td><td>The sample type, which is implied from the data parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>An instance of one of the above window objects. </td></tr>
    <tr><td class="paramname">data</td><td>A reference to the std::array containing the sample data to apply the window to. The array is overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32fa51674b6f683796cc7417542e97dc" name="a32fa51674b6f683796cc7417542e97dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fa51674b6f683796cc7417542e97dc">&#9670;&#160;</a></span>applyWindowFunction() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WindowType, typename T = SampleType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::applyWindowFunction </td>
          <td>(</td>
          <td class="paramtype">WindowType</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a window function to samples inside an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">WindowType</td><td>The class of window function, which is implied from the window parameter. </td></tr>
    <tr><td class="paramname">T</td><td>The sample type, which is implied from the data parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>An instance of one of the above window objects. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the sample data to apply the window to. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data. Note that the window length may be different. The data is overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83519386b0c744ec1c58e02a9f22e26a" name="a83519386b0c744ec1c58e02a9f22e26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83519386b0c744ec1c58e02a9f22e26a">&#9670;&#160;</a></span>autoCorrelateDynamicSizeHalved() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::autoCorrelateDynamicSizeHalved </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do autocorrelation on the input data in a std::vector. The input data is destroyed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The autocorrelation result. </dd></dl>

</div>
</div>
<a id="ad2f74eac40d5e02fc4b1d798f850f7a7" name="ad2f74eac40d5e02fc4b1d798f850f7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f74eac40d5e02fc4b1d798f850f7a7">&#9670;&#160;</a></span>autoCorrelateDynamicSizeHalved() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::autoCorrelateDynamicSizeHalved </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do autocorrelation on the input data. The input data is destroyed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The autocorrelation result. </dd></dl>

</div>
</div>
<a id="a5b9681700449b15a061db6007d0815c2" name="a5b9681700449b15a061db6007d0815c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9681700449b15a061db6007d0815c2">&#9670;&#160;</a></span>autoCorrelateStaticSizeHalved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, unsigned long n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::autoCorrelateStaticSizeHalved </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do autocorrelation on the input data in a std::array. The input data is destroyed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The autocorrelation result. </dd></dl>

</div>
</div>
<a id="af19e51736d4198284ccb3ec9a4c2b7c1" name="af19e51736d4198284ccb3ec9a4c2b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19e51736d4198284ccb3ec9a4c2b7c1">&#9670;&#160;</a></span>boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::boundary </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp a number between a lower and a higher boundary. </p>
<p>If high and low are reversed, this function will always return the value given in low.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type, inferred from the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to clamp. </td></tr>
    <tr><td class="paramname">low</td><td>The lower boundary value. </td></tr>
    <tr><td class="paramname">high</td><td>The higher boundary value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The clamped value. </dd></dl>

</div>
</div>
<a id="af74876c324ecde0826f5c56df11061af" name="af74876c324ecde0826f5c56df11061af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74876c324ecde0826f5c56df11061af">&#9670;&#160;</a></span>calculateMagnitudes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::calculateMagnitudes </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate every magnitude in an FFT. The FFT is overwritten with magnitudes in the first half of the buffer, and zeros in the second half. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a36f34613d8efa455c8291cbecd6372" name="a6a36f34613d8efa455c8291cbecd6372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a36f34613d8efa455c8291cbecd6372">&#9670;&#160;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::clip </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrain a number to a maximum magnitude. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type, inferred from the parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to constrain. </td></tr>
    <tr><td class="paramname">limit</td><td>The maximum magnitude. Must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The constrained value. </dd></dl>

</div>
</div>
<a id="a4fc7aa4ea6fd39f42da645a95cd445bd" name="a4fc7aa4ea6fd39f42da645a95cd445bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc7aa4ea6fd39f42da645a95cd445bd">&#9670;&#160;</a></span>dB2Linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::dB2Linear </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>dB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a dB sample (measurement, gain etc.) to a linear sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dB</td><td>The sample in decibels to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The converted sample. </dd></dl>

</div>
</div>
<a id="a70350ab317997473442253182bda40ef" name="a70350ab317997473442253182bda40ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70350ab317997473442253182bda40ef">&#9670;&#160;</a></span>dsp_assert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::dsp_assert </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>condition</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static global method to enable assertion checking in debug builds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae86a3e6c2cb74bff4444cbca9fdbebc8" name="ae86a3e6c2cb74bff4444cbca9fdbebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86a3e6c2cb74bff4444cbca9fdbebc8">&#9670;&#160;</a></span>expCoef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::expCoef </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>samples</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate an exponential decay coefficient that drops to 1% within a certain number of samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The number of samples to decay by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The resulting coefficient. </dd></dl>

</div>
</div>
<a id="a6afd36f7351fd88289d49f89dead1e95" name="a6afd36f7351fd88289d49f89dead1e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afd36f7351fd88289d49f89dead1e95">&#9670;&#160;</a></span>exponentialCurve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::exponentialCurve </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a linear control to an exponential curve between a minimum and a maximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The smallest allowed output. </td></tr>
    <tr><td class="paramname">max</td><td>The largest allowed output. </td></tr>
    <tr><td class="paramname">input</td><td>The input between 0 and 1. </td></tr>
    <tr><td class="paramname">exp</td><td>The curve factor. Values larger than 0 curve up early, values at 0 are linear and values smaller than 0 curve up late. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The curve mapped value. </dd></dl>

</div>
</div>
<a id="ae8f4d7f6de8b2e0fcade84032fbe4ac6" name="ae8f4d7f6de8b2e0fcade84032fbe4ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f4d7f6de8b2e0fcade84032fbe4ac6">&#9670;&#160;</a></span>exponentialDeltaCurve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::exponentialDeltaCurve </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a linear control to an exponential curve described by a minimum and a delta value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The smallest allowed output. </td></tr>
    <tr><td class="paramname">delta</td><td>The distance fromt he smallest output to the largest output. </td></tr>
    <tr><td class="paramname">input</td><td>The input between 0 and 1. </td></tr>
    <tr><td class="paramname">exp</td><td>The curve factor. Values larger than 0 curve up early, values at 0 are linear and values smaller than 0 curve up late. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The curve mapped value. </dd></dl>

</div>
</div>
<a id="aa44bb322023297302d2a7d1be3e79751" name="aa44bb322023297302d2a7d1be3e79751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44bb322023297302d2a7d1be3e79751">&#9670;&#160;</a></span>expTrack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::expTrack </td>
          <td>(</td>
          <td class="paramtype">SampleType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A quick method which takes a variable passed by reference and decays it towards the target at the given factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A variable passed by reference to decay. </td></tr>
    <tr><td class="paramname">target</td><td>The target value for the variable. </td></tr>
    <tr><td class="paramname">factor</td><td>The decay coefficient, probably calculated with <a class="el" href="#ae86a3e6c2cb74bff4444cbca9fdbebc8" title="Calculate an exponential decay coefficient that drops to 1% within a certain number of samples.">XDDSP::expCoef</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c3f9f1228f7211d9b338ce2a832858" name="a13c3f9f1228f7211d9b338ce2a832858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c3f9f1228f7211d9b338ce2a832858">&#9670;&#160;</a></span>fastBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::fastBoundary </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder method to encapsulate the fastest possible method of clamping a sample between between two samples. </p>
<p>Currently uses std::max and std::min. If min and max are reversed, this function will always return the value given in min.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value to compare. </td></tr>
    <tr><td class="paramname">min</td><td>The lower boundary value. </td></tr>
    <tr><td class="paramname">max</td><td>The higher boundary value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The larger value. </dd></dl>

</div>
</div>
<a id="a2bfc921fa0143efe506fcb074371add7" name="a2bfc921fa0143efe506fcb074371add7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfc921fa0143efe506fcb074371add7">&#9670;&#160;</a></span>fastClip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::fastClip </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder method to encapsulate the fastest possible method of clipping a sample to a maximum magnitude. </p>
<p>Currently uses std::max and std::min.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to constrain. </td></tr>
    <tr><td class="paramname">limit</td><td>The maximum magnitude. Must be positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The constrained value. </dd></dl>

</div>
</div>
<a id="a28800de13ab70bf12e6fb48746ca32b7" name="a28800de13ab70bf12e6fb48746ca32b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28800de13ab70bf12e6fb48746ca32b7">&#9670;&#160;</a></span>fastMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::fastMax </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder method to encapsulate the fastest possible method of computing the maximum between two samples. </p>
<p>Currently uses std::max</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A value to compare. </td></tr>
    <tr><td class="paramname">b</td><td>A value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The larger value. </dd></dl>

</div>
</div>
<a id="abf6c7288a1dc9d8d759f9569085b9bad" name="abf6c7288a1dc9d8d759f9569085b9bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6c7288a1dc9d8d759f9569085b9bad">&#9670;&#160;</a></span>fastMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::fastMin </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder method to encapsulate the fastest possible method of computing the smaller of two samples. </p>
<p>Currently uses std::min</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A value to compare. </td></tr>
    <tr><td class="paramname">b</td><td>A value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The smaller value. </dd></dl>

</div>
</div>
<a id="ad76647b135a18390ad9d051a97397e0f" name="ad76647b135a18390ad9d051a97397e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76647b135a18390ad9d051a97397e0f">&#9670;&#160;</a></span>fftDynamicSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::fftDynamicSize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalise</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an FFT on data in a std::vector. </p>
<p>The input samples are transformed in place from the time domain to the frequency domain. The output consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half. The function <a class="el" href="#a2f46009fa77b26f0939f3f02d9db9d8d" title="Extract a complex sample from an FFT result.">XDDSP::getComplexSample</a> is provided to fetch complex numbers from the resulting array and convert them to std::complex&lt;&gt;</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The vector containing the data. </td></tr>
    <tr><td class="paramname">normalise</td><td>If true, the resulting FFT is normalised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab967fac6eda3e8d7d43c4f9db061e1ef" name="ab967fac6eda3e8d7d43c4f9db061e1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab967fac6eda3e8d7d43c4f9db061e1ef">&#9670;&#160;</a></span>fftDynamicSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::fftDynamicSize </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalise</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an FFT inside an arbitrary buffer. </p>
<p>The input samples are transformed in place from the time domain to the frequency domain. The output consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half. The function <a class="el" href="#a2f46009fa77b26f0939f3f02d9db9d8d" title="Extract a complex sample from an FFT result.">XDDSP::getComplexSample</a> is provided to fetch complex numbers from the resulting array and convert them to std::complex&lt;&gt;</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to transform. The data is overwritten by the transformed data. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the buffer. Must be a power of 2. </td></tr>
    <tr><td class="paramname">normalise</td><td>If true, the transformed data is normalised at the end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cf696b87a8fbae2251aa09ca0689104" name="a6cf696b87a8fbae2251aa09ca0689104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf696b87a8fbae2251aa09ca0689104">&#9670;&#160;</a></span>fftStaticSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, unsigned long n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::fftStaticSize </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>normalise</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an FFT on data in a std::array. </p>
<p>The input samples are transformed in place from the time domain to the frequency domain. The output consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half. The function <a class="el" href="#a2f46009fa77b26f0939f3f02d9db9d8d" title="Extract a complex sample from an FFT result.">XDDSP::getComplexSample</a> is provided to fetch complex numbers from the resulting array and convert them to std::complex&lt;&gt;</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the array, inferred from the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The samples to transform. </td></tr>
    <tr><td class="paramname">normalise</td><td>If true, the resulting FFT is normalised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f46009fa77b26f0939f3f02d9db9d8d" name="a2f46009fa77b26f0939f3f02d9db9d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f46009fa77b26f0939f3f02d9db9d8d">&#9670;&#160;</a></span>getComplexSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T, T &gt; XDDSP::getComplexSample </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a complex sample from an FFT result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Sample type inferred from input parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the sample data. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the complex number sought. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the actual array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;T, T&gt; The complex number returned. </dd></dl>

</div>
</div>
<a id="a37eb3c5613382777208b6577d7a0701a" name="a37eb3c5613382777208b6577d7a0701a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eb3c5613382777208b6577d7a0701a">&#9670;&#160;</a></span>hermite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::hermite </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>fracPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>xm1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermite interpolation. </p>
<p>Performs a cubic interpolation of a curve described by 4 equidistant samples.</p>
<p>Thank you to Laurent de Soras.</p>
<p>Taken from <a href="https://www.musicdsp.org/en/latest/Other/93-hermite-interpollation.html">https://www.musicdsp.org/en/latest/Other/93-hermite-interpollation.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fracPos</td><td>The amount to interpolate between 0 and 1. </td></tr>
    <tr><td class="paramname">xm1</td><td>Sample at position -1. </td></tr>
    <tr><td class="paramname">x0</td><td>Sample at position 0. </td></tr>
    <tr><td class="paramname">x1</td><td>Sample at position 1. </td></tr>
    <tr><td class="paramname">x2</td><td>Sample at position 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The interpolated Sample. </dd></dl>

</div>
</div>
<a id="ae742e09f1ba85045aa0673a52a33cee3" name="ae742e09f1ba85045aa0673a52a33cee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae742e09f1ba85045aa0673a52a33cee3">&#9670;&#160;</a></span>ifftDynamicSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::ifftDynamicSize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The input samples are transformed in place from the frequency domain to the time domain. The input consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0759011c633e1819484046214fbc3720" name="a0759011c633e1819484046214fbc3720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0759011c633e1819484046214fbc3720">&#9670;&#160;</a></span>ifftDynamicSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::ifftDynamicSize </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform an FFT back into the time domain. </p>
<p>The input samples are transformed in place from the frequency domain to the time domain. The input consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to transfer. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the buffer, must be a power of 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf6a3faaf5f63e44e0684a1f6f632427" name="aaf6a3faaf5f63e44e0684a1f6f632427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6a3faaf5f63e44e0684a1f6f632427">&#9670;&#160;</a></span>ifftStaticSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, unsigned long n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::ifftStaticSize </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an inverse FFT on samples in a std::array. </p>
<p>The input samples are transformed in place from the frequency domain to the time domain. The input consists of complex numbers, with the real parts being in the first half of the array and the imaginary parts running backwards in the second half.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the buffer, must be a power of 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3536440b8c33e7e3a21e583f755cdcf3" name="a3536440b8c33e7e3a21e583f755cdcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3536440b8c33e7e3a21e583f755cdcf3">&#9670;&#160;</a></span>inverseExponentialDeltaCurve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::inverseExponentialDeltaCurve </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps an exponential curve value back to a linear value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The smallest allowed output. </td></tr>
    <tr><td class="paramname">delta</td><td>The distance fromt he smallest output to the largest output. </td></tr>
    <tr><td class="paramname">output</td><td>The value on the curve between the minimum and the maximum. </td></tr>
    <tr><td class="paramname">exp</td><td>The curve factor. Values larger than 0 curve up early, values at 0 are linear and values smaller than 0 curve up late. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType A linear value between 0 and 1. </dd></dl>

</div>
</div>
<a id="a72d684c645e0b21ea21c660634b25490" name="a72d684c645e0b21ea21c660634b25490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d684c645e0b21ea21c660634b25490">&#9670;&#160;</a></span>LERP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::LERP </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>fracPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a linear interpolation between two samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fracPos</td><td>The amount to interpolate between 0 and 1. </td></tr>
    <tr><td class="paramname">x0</td><td>Sample at position 0. </td></tr>
    <tr><td class="paramname">x1</td><td>Sample at position 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The interpolated sample. </dd></dl>

</div>
</div>
<a id="a7771496745c2cb5da2ab885b12cfedc0" name="a7771496745c2cb5da2ab885b12cfedc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771496745c2cb5da2ab885b12cfedc0">&#9670;&#160;</a></span>linear2dB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::linear2dB </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a linear sample (measurement, gain etc.) to a dB sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The linear sample to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The converted sample. </dd></dl>

</div>
</div>
<a id="a9ad6f19001c4bae51b38ed50fb9deecd" name="a9ad6f19001c4bae51b38ed50fb9deecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad6f19001c4bae51b38ed50fb9deecd">&#9670;&#160;</a></span>lowestBitSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XDDSP::lowestBitSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index of the lowest bit set in a 32-bit unsigned integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>The 32-bit unsigned integer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The index of the lowest bit set. Returns 0 for no bits set. 1 for the lowest significant bit and 32 for the highest significant bit. </dd></dl>

</div>
</div>
<a id="a928440e390d14ed481c7743382c72c7f" name="a928440e390d14ed481c7743382c72c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928440e390d14ed481c7743382c72c7f">&#9670;&#160;</a></span>magnitudeAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::magnitudeAt </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the magnitude of one complex number in the FFT result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the data buffer. </td></tr>
    <tr><td class="paramname">index</td><td>The index into the buffer. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T The calculated magnitude. </dd></dl>

</div>
</div>
<a id="a13223a5b4d04516032a1c4f98aeedfeb" name="a13223a5b4d04516032a1c4f98aeedfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13223a5b4d04516032a1c4f98aeedfeb">&#9670;&#160;</a></span>multiplyAndAddFFTs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::multiplyAndAddFFTs </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>in1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>in2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two FFTs together and add the result to another FFT result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>A pointer to the output buffer which contains the FFT to be added to. </td></tr>
    <tr><td class="paramname">in1</td><td>A pointer to one FFT input. </td></tr>
    <tr><td class="paramname">in2</td><td>A pointer to the other FFT inpit. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the output buffer, which must be the same as the two input buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a301ddf32610b2c3725c8f42064350a23" name="a301ddf32610b2c3725c8f42064350a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301ddf32610b2c3725c8f42064350a23">&#9670;&#160;</a></span>multiplyFFTs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void XDDSP::multiplyFFTs </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>in1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>in2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a complex multiplication of two FFTs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sample type, inferred from the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>A pointer to a suitable output buffer. </td></tr>
    <tr><td class="paramname">in1</td><td>A pointer to one FFT input. </td></tr>
    <tr><td class="paramname">in2</td><td>A pointer to the other FFT inpit. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the output buffer, which must be the same as the two input buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a495ea5d832c379767c0a40ed981e8b6c" name="a495ea5d832c379767c0a40ed981e8b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ea5d832c379767c0a40ed981e8b6c">&#9670;&#160;</a></span>semitoneRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SampleType XDDSP::semitoneRatio </td>
          <td>(</td>
          <td class="paramtype">SampleType</td>          <td class="paramname"><span class="paramname"><em>st</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the ratio between two equal tempered notes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>The difference betweent the notes in semitones. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SampleType The ratio between the notes. </dd></dl>

</div>
</div>
<a id="a595cef024b93e3dcff48eaec09744c78" name="a595cef024b93e3dcff48eaec09744c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595cef024b93e3dcff48eaec09744c78">&#9670;&#160;</a></span>signum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T XDDSP::signum </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method to calulcate the sign of any number type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The number type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr T -1, 0 or 1, depending on the sign of x </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_x_d_d_s_p.html">XDDSP</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
